#!/usr/bin/bash

die()
{
	echo $* >&2
	exit 1
}

if [[ ! -f $1 || ! -r $1 ]]; then
	die "cannot access input file ‘$1’"
fi

if [[ -z $2 || -z $3 ]]; then
	die 'missing output file'
fi

iputs()
{
	if [[ $1 -gt 0 ]]; then
		printf '\t%.0s' $(seq 1 $1)
	fi
	printf '%s' "$2"

	if [[ ! $3 ]]; then
		echo
	fi
}

get_num()
{
	echo $* | wc -w
}

get_seconds()
{
	echo $* | awk -F: '{ print ($1 * 3600) + ($2 * 60) + $3 }'
}

parse_schedule()
{
	parsing=
	fnum=0
	unum=0
	while read; do
		case "$REPLY" in
		'')
			if [[ $parsing ]]; then
				iputs 0       ' },'
				iputs 4       ".unum  = $unum,"
				iputs 3     '},'
				iputs 2   '},'
				iputs 2   ".fnum  = $fnum,"
				iputs 1 '},'

				parsing=
				fnum=0
			fi
			;&
		'#'*)
			continue
			;;
		$'\t'*)
			read -a data <<< "$REPLY"
			(( unum += $(get_num ${data[@]}) ))

			printf ', 0x%s' ${data[@]}
			;;
		*)
			read time data <<< "$REPLY"
			cnum=$(get_num $data)

			read -a data <<< "$data"
			local last=${data[-1]}
			unset data[-1]

			isbit=0
			if [[ $data == 'B' ]]; then
				unset data[0]
				(( cnum-- ))
				isbit=1
			fi

			if [[ ! $parsing ]]; then
				parsing=1

				iputs 1 '{'
				iputs 2   ".start = $(get_seconds $time),"
				iputs 2   '.frame = (struct frame_info[]){'
				iputs 3     '{'
				iputs 4       '.delay = 0,'
			else
				if [[ $prev_isbit -eq 1 ]]; then
					prev_isbit=0
				else
					iputs 0       ' },'
				fi
				iputs 4       ".unum  = $unum,"
				iputs 3     '},'
				iputs 3     '{'
				iputs 4       ".delay = $time,"
			fi

			if [[ $isbit -eq 1 ]]; then
				iputs 4       ".lldat = (uint32_t[]){" -n
				printf        ' %s,' ${data[@]}
				printf        ' %s ' $last
				iputs 0       '},'
				iputs 4       ".bnum  = $cnum,"
				iputs 4       '.cnum  = 0,'
				iputs 4       '.data  = 0,'

				prev_isbit=1
			else
				iputs 4       '.lldat = 0,'
				iputs 4       '.bnum  = 0,'
				iputs 4       ".cnum  = $cnum,"
				iputs 4       ".data  = (uint8_t[]){" -n
				printf        ' 0x%s,' ${data[@]}
				printf        ' 0x%s' $last
			fi

			(( fnum++ ))
			unum=0
			;;
		esac
	done < <(cat $1; echo)
}

echo '/* Automatically generated by schedule-signal <barroit> */

#ifndef SIGNAL_SCHEDULE_DEF_H
#define SIGNAL_SCHEDULE_DEF_H

#include <stdint.h>
#include <stddef.h>

struct frame_info {
	uint8_t *data;
	uint32_t *lldat;
	size_t cnum;
	size_t unum;
	size_t bnum;
	uint8_t delay;
};

struct signal_schedule {
	uint64_t start;
	struct frame_info *frame;
	size_t fnum;
};

/**
 * In this case, using 'typedef' is appropriate since we don’t access the
 * fields in the 'end-user API'; we simply use these structs as a type.
 */
typedef struct frame_info frame_info_t;
typedef struct signal_schedule signal_schedule_t;

#endif /* SIGNAL_SCHEDULE_DEF_H */' > $2

{
echo "/* Automatically generated by schedule-signal <barroit> */

#ifdef SIGNAL_SCHEDULE_AUTOGEN_H
#error "The signal schedule should be included only once"
#endif

#define SIGNAL_SCHEDULE_AUTOGEN_H

#include \"$2\"
"
echo 'static const struct signal_schedule schedules[] = {'
	parse_schedule $1
echo '};'
} > $3
